<!DOCTYPE html>
<html lang="zh-CN">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>量子银河树</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            user-select: none;
        }

        /* --- 3D Scene Container --- */
        #canvas-container {
            width: 100vw;
            height: 100vh;
            display: block;
            opacity: 1;
        }

        /* --- UI Overlay --- */
        #ui {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 255, 255, 0.8);
            text-align: center;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            z-index: 10;
        }

        h1 {
            margin: 0;
            font-weight: 300;
            letter-spacing: 5px;
            font-size: 2rem;
            background: linear-gradient(90deg, #ff9a9e, #fecfef, #f6d365);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        p {
            font-size: 0.9rem;
            margin-top: 5px;
            opacity: 0.7;
        }

        /* --- MediaPipe Hidden Video --- */
        #input_video {
            position: absolute;
            top: 0;
            left: 0;
            width: 320px;
            height: 240px;
            opacity: 0;
            z-index: -10;
            pointer-events: none;
        }

        /* Status & Indicator */
        #debug-status {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(0, 255, 255, 0.7);
            font-size: 12px;
            font-family: monospace;
            z-index: 100;
        }

        #hand-indicator {
            position: absolute;
            bottom: 30px;
            right: 30px;
            width: 15px;
            height: 15px;
            background-color: #333;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.3);
            transition: background-color 0.2s, transform 0.2s, box-shadow 0.2s;
            z-index: 100;
        }

        #hand-indicator.active {
            background-color: #00ffff;
            box-shadow: 0 0 15px #00ffff;
        }

        /* --- Loading Screen --- */
        #loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0a0a1a 0%, #1a0a2e 50%, #0a1a2a 100%);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.8s ease-out;
        }

        #loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-title {
            font-size: 2rem;
            color: #fff;
            margin-bottom: 30px;
            background: linear-gradient(90deg, #ff9a9e, #fecfef, #a18cd1);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: pulse 2s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.6;
            }
        }

        .progress-container {
            width: 300px;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            overflow: hidden;
            margin-bottom: 15px;
        }

        .progress-bar {
            height: 100%;
            width: 0%;
            background: linear-gradient(90deg, #00ffff, #a18cd1, #ff9a9e);
            border-radius: 3px;
            transition: width 0.3s ease-out;
        }

        .loading-status {
            color: rgba(255, 255, 255, 0.6);
            font-size: 0.9rem;
        }

        .loading-tip {
            color: rgba(255, 255, 255, 0.4);
            font-size: 0.75rem;
            margin-top: 40px;
            max-width: 280px;
            text-align: center;
            line-height: 1.5;
        }
    </style>
</head>

<body>

    <!-- Loading Screen -->
    <div id="loading-screen">
        <div class="loading-title">✨ 量子银河树 ✨</div>
        <div class="progress-container">
            <div class="progress-bar" id="progress-bar"></div>
        </div>
        <div class="loading-status" id="loading-status">正在加载核心库...</div>
        <div class="loading-tip">首次加载需要下载AI手势识别模型，请耐心等待</div>
    </div>

    <video id="input_video" playsinline webkit-playsinline muted autoplay></video>
    <div id="debug-status">系统初始化中...</div>
    <div id="hand-indicator"></div>

    <div id="ui">
        <p>张开手指：圣诞树 -> 银河系 | 握拳：恢复 | 左右移动控制旋转</p>
    </div>
    <div id="canvas-container"></div>

    <!-- Scripts (本地化) -->
    <script src="libs/three/three.min.js"></script>
    <script src="libs/three/OrbitControls.js"></script>
    <script src="libs/mediapipe/camera_utils.js"></script>
    <script src="libs/mediapipe/control_utils.js"></script>
    <script src="libs/mediapipe/hands/hands.js"></script>

    <!-- Post-processing Scripts (本地化) -->
    <script src="libs/three/CopyShader.js"></script>
    <script src="libs/three/LuminosityHighPassShader.js"></script>
    <script src="libs/three/EffectComposer.js"></script>
    <script src="libs/three/RenderPass.js"></script>
    <script src="libs/three/ShaderPass.js"></script>
    <script src="libs/three/UnrealBloomPass.js"></script>

    <script>
        // --- GLOBAL STATE ---
        const STATE = {
            handDetected: false,
            openness: 0,
            targetOpenness: 0,
            handX: 0.5, // 0 (Left) to 1 (Right), default center
            targetHandX: 0.5,
            smoothness: 0.08
        };

        // --- LOADING PROGRESS ---
        const loadingScreen = document.getElementById('loading-screen');
        const progressBar = document.getElementById('progress-bar');
        const loadingStatus = document.getElementById('loading-status');
        let loadProgress = 0;

        function updateProgress(percent, status) {
            loadProgress = percent;
            progressBar.style.width = percent + '%';
            loadingStatus.textContent = status;
        }

        function hideLoadingScreen() {
            loadingScreen.classList.add('hidden');
            setTimeout(() => {
                loadingScreen.style.display = 'none';
            }, 800);
        }

        // Initial progress
        updateProgress(20, '核心库已加载，正在初始化手势识别...');

        // --- MEDIAPIPE ---
        const videoElement = document.getElementById('input_video');
        const debugStatus = document.getElementById('debug-status');
        const handIndicator = document.getElementById('hand-indicator');

        // --- DEBUG VARIABLES ---
        let frameCount = 0;
        let lastFrameTime = 0;
        let lastSendTime = 0;
        let sendCount = 0;
        let handsReady = false;

        function onResults(results) {
            frameCount++;
            const now = performance.now();
            const fps = lastFrameTime > 0 ? (1000 / (now - lastFrameTime)) : 0;
            lastFrameTime = now;

            // Log every 30 frames to avoid spam
            if (frameCount % 30 === 1) {
                console.log(`[MediaPipe] onResults called. Frame: ${frameCount}, FPS: ${fps.toFixed(1)}, Hands detected: ${results.multiHandLandmarks?.length || 0}`);
            }

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                STATE.handDetected = true;
                handIndicator.classList.add('active');

                const landmarks = results.multiHandLandmarks[0];
                const wrist = landmarks[0];
                const middleMCP = landmarks[9];

                const fingerIndices = [8, 12, 16, 20];
                const mcpIndices = [5, 9, 13, 17];
                let totalRatio = 0;

                for (let i = 0; i < 4; i++) {
                    const tip = landmarks[fingerIndices[i]];
                    const mcp = landmarks[mcpIndices[i]];
                    const distTip = Math.hypot(tip.x - wrist.x, tip.y - wrist.y);
                    const distMcp = Math.hypot(mcp.x - wrist.x, mcp.y - wrist.y);
                    if (distMcp > 0.001) {
                        totalRatio += distTip / distMcp;
                    }
                }

                const avgRatio = totalRatio / 4;
                const minRatio = 1.1;
                const maxRatio = 1.7;
                let rawOpenness = (avgRatio - minRatio) / (maxRatio - minRatio);
                if (rawOpenness < 0) rawOpenness = 0;
                if (rawOpenness > 1) rawOpenness = 1;

                STATE.targetOpenness = rawOpenness;
                STATE.targetHandX = middleMCP.x;

                debugStatus.textContent = `✓ 检测到手势 | FPS: ${fps.toFixed(1)} | 手指比例: ${avgRatio.toFixed(2)} | 张开度: ${rawOpenness.toFixed(2)}`;
                debugStatus.style.color = '#00ff00';

                const scale = 1 + STATE.targetOpenness * 1.5;
                handIndicator.style.transform = `scale(${scale})`;

            } else {
                STATE.handDetected = false;
                STATE.targetOpenness = 0;
                STATE.targetHandX = 0.5;
                handIndicator.classList.remove('active');
                handIndicator.style.transform = `scale(1)`;
                debugStatus.textContent = `处理中 | FPS: ${fps.toFixed(1)} | 帧数: ${frameCount} | 等待手势...`;
                debugStatus.style.color = 'rgba(0, 255, 255, 0.7)';
            }
        }

        updateProgress(30, '正在加载AI手势识别模型...');
        console.log('[MediaPipe] Creating Hands instance...');

        const hands = new Hands({
            locateFile: (file) => {
                const path = `libs/mediapipe/hands/${file}?t=${Date.now()}`;
                console.log(`[MediaPipe] Loading file: ${path}`);
                updateProgress(40, '正在加载模型: ' + file.substring(0, 25) + '...');
                return path;
            }
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // Initialize the model proactively
        console.log('[MediaPipe] Initializing hands model...');
        hands.initialize().then(() => {
            console.log('[MediaPipe] ✓ Hands model initialized successfully!');
            handsReady = true;
            updateProgress(60, 'AI模型初始化完成!');
        }).catch(err => {
            console.error('[MediaPipe] ✗ Hands model initialization failed:', err);
            debugStatus.textContent = '错误: AI模型加载失败 - ' + err.message;
            debugStatus.style.color = '#ff0000';
        });

        // --- INIT CHECKS ---
        window.addEventListener('load', () => {
            console.log('[System] Page loaded. Secure context:', window.isSecureContext);
            if (!window.isSecureContext && window.location.hostname !== 'localhost' && window.location.hostname !== '127.0.0.1') {
                const msg = "警告：当前环境不安全(HTTP)，无法访问摄像头。\n请使用 HTTPS 协议或 localhost 访问。";
                debugStatus.textContent = "环境不安全：缺少 HTTPS";
                debugStatus.style.color = '#ff0000';
                alert(msg);
            }
        });

        function startCamera() {
            updateProgress(90, '正在请求摄像头权限...');
            debugStatus.textContent = "正在请求摄像头...";
            console.log('[Camera] Starting camera initialization...');

            const camera = new Camera(videoElement, {
                onFrame: async () => {
                    sendCount++;

                    // Check if video has valid content
                    if (sendCount === 1) {
                        console.log('[Camera] First frame received!');
                        console.log('[Camera] Video dimensions:', videoElement.videoWidth, 'x', videoElement.videoHeight);
                        console.log('[Camera] Video ready state:', videoElement.readyState);
                    }

                    // Log every 60 frames
                    if (sendCount % 60 === 1) {
                        console.log(`[Camera] Sending frame #${sendCount} to MediaPipe. Video ready: ${videoElement.readyState >= 2}`);
                    }

                    // Check if video has valid dimensions before sending
                    if (videoElement.videoWidth > 0 && videoElement.videoHeight > 0) {
                        try {
                            await hands.send({ image: videoElement });
                        } catch (e) {
                            console.error("Hands send error:", e);
                            debugStatus.textContent = "AI处理错误: " + e.message;
                        }
                    } else if (sendCount < 10) {
                        console.warn('[Camera] Video not ready yet, waiting...');
                    }
                },
                width: 640,
                height: 480
            });

            console.log('[Camera] Camera object created, starting...');

            camera.start()
                .then(() => {
                    // Success (promise resolves when camera starts)
                    console.log("Camera started successfully");
                    debugStatus.textContent = "摄像头已启动 | 等待手势...";
                    updateProgress(100, '加载完成!');
                    setTimeout(hideLoadingScreen, 500);

                    // Watchdog: Check if data starts flowing
                    setTimeout(() => {
                        if (frameCount === 0) {
                            debugStatus.textContent = "警告: AI模型未响应 (请检查libs文件是否完整)";
                            console.warn("MediaPipe Hands not producing results.");
                        }
                    }, 5000);
                })
                .catch(err => {
                    console.error("Camera error:", err);
                    let errorMsg = "摄像头启动失败：未知错误";

                    if (err.name === 'NotAllowedError' || err.name === 'PermissionDeniedError') {
                        errorMsg = "摄像头权限被拒绝。请在浏览器设置中允许访问摄像头。";
                    } else if (err.name === 'NotFoundError' || err.name === 'DevicesNotFoundError') {
                        errorMsg = "未找到摄像头设备。";
                    } else if (err.name === 'NotReadableError' || err.name === 'TrackStartError') {
                        errorMsg = "摄像头可能被其他应用占用，或发生硬件错误。";
                    } else if (err.name === 'OverconstrainedError') {
                        errorMsg = "摄像头不支持请求的分辨率或配置。";
                    } else if (location.protocol !== 'https:' && location.hostname !== 'localhost') {
                        errorMsg = "浏览器禁止在非 HTTPS 环境下访问摄像头。";
                    }

                    debugStatus.textContent = "错误：" + errorMsg;
                    alert(errorMsg + "\n\n详细信息: " + err.name);
                    // 即使摄像头失败也隐藏加载屏幕，允许用户看到场景
                    updateProgress(100, '加载完成 (摄像头不可用)');
                    setTimeout(hideLoadingScreen, 500);
                });
        }

        // --- THREE.JS ---
        const CONFIG = {
            treeHeight: 60,
            baseRadius: 25,
            particleCount: 20000,
            snowCount: 2000,
            galaxyRadius: 70,
            spinSpeed: 0.002,
            treeColors: [0xff9a9e, 0xa18cd1, 0xffd700, 0xffffff],
            galaxyColors: [0x00ffff, 0x2200cc, 0x8800ff, 0xffffff, 0x0033ff],
            meteorCount: 8,
            meteorColor: 0xaaddff
        };

        let scene, camera, renderer, controls, composer;
        let treeSystem, snowSystem, starMesh, trunkSystem;
        let starParticles; // New global
        let starSpeeds = []; // Fixed speeds for each star particle
        let meteors = [];
        let clock = new THREE.Clock();

        let treePositionsAttr, galaxyPositionsAttr;
        let treeColorsAttr, galaxyColorsAttr;

        function init() {
            updateProgress(60, '正在创建3D场景...');
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050510, 0.002);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 40, 100);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.toneMapping = THREE.ReinhardToneMapping;
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            controls = new THREE.OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = true;
            controls.autoRotateSpeed = 1.0;
            controls.maxPolarAngle = Math.PI / 1.6;

            createMorphingTree();
            createTrunk();
            createStardustStar(); // Switched to new star
            createSnow();
            createMeteors();
            createGroundReflection();
            addLights();

            // --- Post-processing ---
            const renderScene = new THREE.RenderPass(scene, camera);

            const bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                1.5, // Strength (Glow intensity)
                0.4, // Radius
                0.85 // Threshold
            );
            bloomPass.threshold = 0.05; // Slightly lower threshold to catch more glow
            bloomPass.strength = 1.1; // Increased from 0.8
            bloomPass.radius = 0.5;

            composer = new THREE.EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            window.addEventListener('resize', onWindowResize, false);
            updateProgress(80, '场景创建完成，正在初始化摄像头...');
            startCamera();
            window.addEventListener('click', () => {
                if (debugStatus.textContent.includes("Blocked")) startCamera();
            });

            animate();
        }

        function createMorphingTree() {
            const geometry = new THREE.BufferGeometry();
            const currentPositions = [];
            const currentColors = [];
            const sizes = [];

            const treePos = [];
            const galaxyPos = [];
            const treeCol = [];
            const galaxyCol = [];

            const colorHelper1 = new THREE.Color();
            const colorHelper2 = new THREE.Color();

            for (let i = 0; i < CONFIG.particleCount; i++) {
                // --- Tree ---
                const t = Math.pow(Math.random(), 0.8);
                const treeAngle = t * Math.PI * 30 + (Math.random() * 0.5);
                const treeR = (1 - t) * CONFIG.baseRadius + (Math.random() * 2);

                const tx = Math.cos(treeAngle) * treeR;
                const ty = t * CONFIG.treeHeight - (CONFIG.treeHeight / 2) + 5;
                const tz = Math.sin(treeAngle) * treeR;

                treePos.push(tx, ty, tz);

                // --- Galaxy ---
                const armCount = 5;
                const armOffset = (i % armCount) * (Math.PI * 2 / armCount);
                const gR = Math.pow(Math.random(), 0.5) * CONFIG.galaxyRadius;
                const spinFactor = 4;
                const gAngle = armOffset + (gR / CONFIG.galaxyRadius) * spinFactor * Math.PI + (Math.random() * 0.5);

                const gx = Math.cos(gAngle) * gR;
                const gy = (Math.random() - 0.5) * (12 * (1 - gR / CONFIG.galaxyRadius));
                const gz = Math.sin(gAngle) * gR;

                galaxyPos.push(gx, gy, gz);

                // --- Colors ---
                const tColorIndex = Math.floor(Math.random() * CONFIG.treeColors.length);
                colorHelper1.setHex(CONFIG.treeColors[tColorIndex]);
                if (Math.random() > 0.8) colorHelper1.offsetHSL(0, 0, 0.2);
                treeCol.push(colorHelper1.r, colorHelper1.g, colorHelper1.b);

                const gColorIndex = Math.floor(Math.random() * CONFIG.galaxyColors.length);
                colorHelper2.setHex(CONFIG.galaxyColors[gColorIndex]);
                if (gR < 15) {
                    colorHelper2.setHex(0xffffff);
                    colorHelper2.offsetHSL(0, 0, -0.1);
                }
                galaxyCol.push(colorHelper2.r, colorHelper2.g, colorHelper2.b);

                // --- Init ---
                currentPositions.push(tx, ty, tz);
                currentColors.push(colorHelper1.r, colorHelper1.g, colorHelper1.b);
                sizes.push(0.5);
            }

            treePositionsAttr = new Float32Array(treePos);
            galaxyPositionsAttr = new Float32Array(galaxyPos);
            treeColorsAttr = new Float32Array(treeCol);
            galaxyColorsAttr = new Float32Array(galaxyCol);

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(currentPositions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(currentColors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                size: 1.0,
                map: getTexture(),
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.9,
                sizeAttenuation: true
            });

            treeSystem = new THREE.Points(geometry, material);
            scene.add(treeSystem);
        }

        function createTrunk() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const count = 3000;
            const height = CONFIG.treeHeight * 0.9;
            const color = new THREE.Color(0xffaa33);

            for (let i = 0; i < count; i++) {
                const t = i / count;
                const angle = t * Math.PI * 40;
                const radius = 1.5 + Math.random() * 0.5;
                const offset = (i % 2 === 0) ? 0 : Math.PI;
                const x = Math.cos(angle + offset) * radius;
                const y = t * height - (CONFIG.treeHeight / 2);
                const z = Math.sin(angle + offset) * radius;
                positions.push(x, y, z);
                colors.push(color.r, color.g, color.b);
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            const material = new THREE.PointsMaterial({
                size: 0.4,
                map: getTexture(),
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.6
            });
            trunkSystem = new THREE.Points(geometry, material);
            scene.add(trunkSystem);
        }

        function createStardustStar() {
            const particleCount = 200;
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const sizes = [];
            starSpeeds = []; // Reset speeds array
            const color = new THREE.Color();

            for (let i = 0; i < particleCount; i++) {
                const r = Math.random() * 2;
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.acos(2 * Math.random() - 1);

                const x = r * Math.sin(phi) * Math.cos(theta);
                const y = r * Math.sin(phi) * Math.sin(theta);
                const z = r * Math.cos(phi);

                positions.push(x, y, z);

                // Store fixed speed for this particle (used in animation)
                starSpeeds.push(0.015 + Math.random() * 0.015);

                if (Math.random() > 0.5) {
                    color.setHex(0xffd700); // Gold
                } else {
                    color.setHex(0xffffff); // White
                }
                colors.push(color.r, color.g, color.b);
                sizes.push(0.5 + Math.random() * 1.5);
            }

            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

            const material = new THREE.PointsMaterial({
                size: 0.5,
                map: getTexture(),
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 1
            });

            starParticles = new THREE.Points(geometry, material);
            starMesh = starParticles;

            starMesh.position.y = CONFIG.treeHeight / 2 + 5;
            scene.add(starMesh);

            const light = new THREE.PointLight(0xffaa00, 3, 40);
            light.position.y = CONFIG.treeHeight / 2 + 5;
            scene.add(light);

            const spriteMat = new THREE.SpriteMaterial({
                map: getTexture(),
                color: 0xffffee,
                transparent: true,
                blending: THREE.AdditiveBlending,
                opacity: 0.5
            });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.scale.set(10, 10, 1);
            starMesh.add(sprite);
        }

        function createTopStar() {
            const group = new THREE.Group();

            // 1. Quantum Core (Glowing Crystal)
            const coreGeo = new THREE.IcosahedronGeometry(2, 0);
            const coreMat = new THREE.MeshBasicMaterial({ color: 0xffffff }); // White hot
            const core = new THREE.Mesh(coreGeo, coreMat);
            group.add(core);

            // 2. Outer Cage (Wireframe Energy Field)
            const cageGeo = new THREE.IcosahedronGeometry(3.5, 1);
            const cageMat = new THREE.MeshBasicMaterial({
                color: 0x00ffff,
                wireframe: true,
                transparent: true,
                opacity: 0.5
            });
            const cage = new THREE.Mesh(cageGeo, cageMat);
            cage.userData = { isCage: true };
            group.add(cage);

            // 3. Light Rays (Spikes)
            const spikeGeo = new THREE.ConeGeometry(0.2, 12, 4);
            spikeGeo.translate(0, 6, 0);
            const spikeMat = new THREE.MeshBasicMaterial({ color: 0xffd700 });

            // Create a 6-pointed 3D star shape
            const directions = [
                new THREE.Vector3(1, 0, 0), new THREE.Vector3(-1, 0, 0),
                new THREE.Vector3(0, 1, 0), new THREE.Vector3(0, -1, 0),
                new THREE.Vector3(0, 0, 1), new THREE.Vector3(0, 0, -1)
            ];

            directions.forEach(dir => {
                const spike = new THREE.Mesh(spikeGeo, spikeMat);
                spike.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), dir);
                group.add(spike);
            });

            // 4. Glow Shield
            const glowGeo = new THREE.SphereGeometry(4, 32, 32);
            const glowMat = new THREE.MeshBasicMaterial({
                color: 0xffd700,
                transparent: true,
                opacity: 0.15,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            group.add(glow);

            starMesh = group;
            starMesh.position.y = CONFIG.treeHeight / 2 + 5;
            scene.add(starMesh);

            // Point Light
            const light = new THREE.PointLight(0xffaa00, 2, 60);
            light.position.y = CONFIG.treeHeight / 2 + 5;
            scene.add(light);
        }

        function createSnow() {
            const geometry = new THREE.BufferGeometry();
            const positions = [];
            for (let i = 0; i < CONFIG.snowCount; i++) {
                const x = Math.random() * 100 - 50;
                const y = Math.random() * 100 - 20;
                const z = Math.random() * 100 - 50;
                positions.push(x, y, z);
            }
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const material = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.4,
                map: getTexture(),
                blending: THREE.AdditiveBlending,
                depthWrite: false,
                transparent: true,
                opacity: 0.6
            });
            snowSystem = new THREE.Points(geometry, material);
            scene.add(snowSystem);
        }

        function createGroundReflection() {
            const gridHelper = new THREE.GridHelper(200, 40, 0x442244, 0x110511);
            gridHelper.position.y = -CONFIG.treeHeight / 2 - 2;
            scene.add(gridHelper);
        }

        function addLights() {
            const ambientLight = new THREE.AmbientLight(0x000000);
            scene.add(ambientLight);
            const lights = [0xff9a9e, 0xa18cd1, 0xffd700];
            lights.forEach((color, i) => {
                const light = new THREE.PointLight(color, 1, 60);
                const angle = (i / lights.length) * Math.PI * 2;
                light.position.set(Math.cos(angle) * 30, 0, Math.sin(angle) * 30);
                scene.add(light);
            });
        }

        function getTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const context = canvas.getContext('2d');
            const gradient = context.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.2, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.5, 'rgba(255,255,255,0.2)');
            gradient.addColorStop(1, 'rgba(0,0,0,0)');
            context.fillStyle = gradient;
            context.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();

            STATE.openness += (STATE.targetOpenness - STATE.openness) * STATE.smoothness;
            STATE.handX += (STATE.targetHandX - STATE.handX) * STATE.smoothness;

            const morphFactor = STATE.openness;
            const isGalaxy = morphFactor > 0.6;

            // 1. UPDATE PARTICLES
            if (treeSystem && treePositionsAttr && galaxyPositionsAttr) {
                const positions = treeSystem.geometry.attributes.position.array;
                const colors = treeSystem.geometry.attributes.color.array;
                const count = CONFIG.particleCount;

                if (Math.abs(morphFactor - 0) > 0.001 || Math.abs(morphFactor - 1) > 0.001 || STATE.targetOpenness > 0) {
                    for (let i = 0; i < count; i++) {
                        const idx = i * 3;

                        let localT = morphFactor * (1 + Math.sin(i * 0.5) * 0.2);
                        if (localT > 1) localT = 1;
                        if (localT < 0) localT = 0;

                        positions[idx] = treePositionsAttr[idx] + (galaxyPositionsAttr[idx] - treePositionsAttr[idx]) * localT;
                        positions[idx + 1] = treePositionsAttr[idx + 1] + (galaxyPositionsAttr[idx + 1] - treePositionsAttr[idx + 1]) * localT;
                        positions[idx + 2] = treePositionsAttr[idx + 2] + (galaxyPositionsAttr[idx + 2] - treePositionsAttr[idx + 2]) * localT;

                        colors[idx] = treeColorsAttr[idx] + (galaxyColorsAttr[idx] - treeColorsAttr[idx]) * localT;
                        colors[idx + 1] = treeColorsAttr[idx + 1] + (galaxyColorsAttr[idx + 1] - treeColorsAttr[idx + 1]) * localT;
                        colors[idx + 2] = treeColorsAttr[idx + 2] + (galaxyColorsAttr[idx + 2] - treeColorsAttr[idx + 2]) * localT;
                    }
                    treeSystem.geometry.attributes.position.needsUpdate = true;
                    treeSystem.geometry.attributes.color.needsUpdate = true;
                }

                if (isGalaxy) {
                    const control = (STATE.handX - 0.5) * 2;
                    const maxSpin = 0.05;
                    treeSystem.rotation.y -= control * maxSpin;
                } else {
                    treeSystem.rotation.y -= 0.002;
                }
            }

            // 2. Trunk Fading
            if (trunkSystem) {
                const trunkScale = 1 - morphFactor;
                trunkSystem.scale.set(trunkScale, trunkScale, trunkScale);
                trunkSystem.material.opacity = (1 - morphFactor) * 0.6;
                trunkSystem.rotation.y += 0.002;
            }

            // 3. Star Animation (Stardust Cluster)
            if (starParticles) {
                const positions = starParticles.geometry.attributes.position.array;

                // Swirl animation with fixed per-particle speeds
                for (let i = 0; i < positions.length; i += 3) {
                    const x = positions[i];
                    const z = positions[i + 2];

                    // Use fixed speed stored at creation time for smooth rotation
                    const particleIndex = i / 3;
                    const angle = starSpeeds[particleIndex] || 0.02;

                    positions[i] = x * Math.cos(angle) - z * Math.sin(angle);
                    positions[i + 2] = x * Math.sin(angle) + z * Math.cos(angle);
                }
                starParticles.geometry.attributes.position.needsUpdate = true;

                // Breathing scale
                const scale = 1 + Math.sin(time * 1.5) * 0.2 + morphFactor * 2;
                starParticles.scale.set(scale, scale, scale);

                // Rotation
                starParticles.rotation.y -= 0.005;
                starParticles.rotation.z = Math.sin(time * 0.5) * 0.1;
            }

            // 4. Snow
            if (snowSystem) {
                const positions = snowSystem.geometry.attributes.position.array;
                const gravity = isGalaxy ? 0.3 : -0.15;
                const limit = 60;

                for (let i = 1; i < positions.length; i += 3) {
                    positions[i] += gravity;
                    if (isGalaxy) {
                        if (positions[i] > limit) positions[i] = -limit;
                    } else {
                        if (positions[i] < -limit) positions[i] = limit;
                    }
                }
                snowSystem.geometry.attributes.position.needsUpdate = true;
                snowSystem.rotation.y += 0.001;
            }

            // 5. Meteors
            updateMeteors();

            controls.update();
            // renderer.render(scene, camera);
            composer.render();
        }

        function createMeteors() {
            const geometry = new THREE.ConeGeometry(0.2, 40, 8);
            geometry.translate(0, 20, 0); // Tail follows head
            geometry.rotateX(Math.PI / 2); // Align with Z for lookAt, or adjust dynamically

            const material = new THREE.MeshBasicMaterial({
                color: CONFIG.meteorColor,
                transparent: true,
                opacity: 0,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            for (let i = 0; i < CONFIG.meteorCount; i++) {
                const mesh = new THREE.Mesh(geometry, material.clone());
                mesh.userData = { active: false, speed: 0 };
                scene.add(mesh);
                meteors.push(mesh);
            }
        }

        function updateMeteors() {
            meteors.forEach(mesh => {
                if (mesh.userData.active) {
                    mesh.translateZ(mesh.userData.speed);
                    mesh.material.opacity -= 0.015;
                    if (mesh.position.y < -50 || mesh.material.opacity <= 0) {
                        mesh.userData.active = false;
                        mesh.visible = false;
                    }
                } else {
                    if (Math.random() < 0.005) { // Spawn chance
                        spawnMeteor(mesh);
                    }
                }
            });
        }

        function spawnMeteor(mesh) {
            mesh.userData.active = true;
            mesh.visible = true;
            mesh.material.opacity = 1;
            mesh.userData.speed = 4 + Math.random() * 2;

            // Random High Position (Wider spread to cover the sky)
            // Bias start X to positive so they travel leftwards
            const startX = 50 + (Math.random() - 0.5) * 400;
            const startY = 150 + Math.random() * 100;
            const startZ = (Math.random() - 0.5) * 400;
            mesh.position.set(startX, startY, startZ);

            // Unified Direction: Top-Right to Bottom-Left 
            // Fixed Delta vector ensures parallel paths
            const deltaX = -100; // Move Left
            const deltaY = -200; // Move Down
            const deltaZ = 20;   // Slight forward tilt

            const targetX = startX + deltaX;
            const targetY = startY + deltaY;
            const targetZ = startZ + deltaZ;

            mesh.lookAt(targetX, targetY, targetZ);
        }

        window.onload = init;
    </script>
</body>

</html>